% by Sean McKenna

\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}

%%% PAGE DIMENSIONS
\usepackage{geometry}
\geometry{a4paper}

\usepackage{booktabs}
\usepackage{array}
\usepackage{verbatim}
\usepackage{subfig}
\usepackage{amssymb,amsmath}
\usepackage{graphicx} 
\usepackage{fancyhdr}
\pagestyle{fancy}
\renewcommand{\headrulewidth}{0pt}
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}
\addtolength{\oddsidemargin}{-.875in}
\addtolength{\evensidemargin}{-.875in}
\addtolength{\textwidth}{1.5in}
\addtolength{\textheight}{1.0in}
%\addtolength{\topmargin}{-.575in}

\linespread{2}

\title{Examination 3}
\author{Sean McKenna}

\begin{document}

\begin{center}
  \textbf{CSC 321 - Examination 3} \\
  by Sean McKenna
\end{center}

\begin{enumerate}
  %#1
  \item
    \begin{enumerate}
      \item The dot product of two unit vectors yields a value between -1 and 1 depending on the angle of the two vectors. If the vectors are perpendicular, it will produce 0. And if the vectors are parallel then it will produce a value of 1 (or -1 if parallel in opposite directions). Negative values occur when the angle between the two vectors is less than $\pi / 2$ or 90 degrees. Anywhere else (less than that) yields a value in-between 0 and 1.
      \item The cross product yields another vector which is normal/perpendicular to the plane in which the two vectors lie.
      \item $(\vec{u} \times \vec{v}) \cdot (\vec{v} \times \vec{u}) = -1$. This is the case because the two cross products produce vectors in the opposite direction which the dot product of that is -1 since they are not entirely parallel.
    \end{enumerate}

  %#2
  \item For the AffineTransform class, it is true that a 3x3 matrix will only affect a 2-D image, since it requires an extra dimension to handle the essential canonical description of the transform (kind of like scaling but fundamentally different). What this means is that the last row in the matrix is untouched, leaving all 0's and ending with a 1 in the final column of the last row. Thus, instead of 9 options to transform a 2-D image, this leaves $9 - 3 = 6$ options to transform the image.

  %#3
  \item The transformation in this problem first starts with some vector $\vec{v}$ which is then translated back to $(-d_x,-d_y)$. Then, the vector is rotated about the z-axis by some angle $\psi$. The transformation finishes with an operation to shift the object back by adding to its current coordinates $(d_x,d_y)$. So, this means that we have to shift the coordinates of the turbine to the origin before rotating and then must shift the coordinates back after, essentially rotating about $(d_x,d_y)$.

  %#4
  \item For some vector $\vec{v}$ it is first translated so that one corner of the box lies at $(0,0,0)$ and the other would then lie in the positive x, y, and z plane at point $(x_{max} - x_{min},y_{max} - y_{min},z_{max} - z_{min})$. Then, the vector is scaled with respect to this value in such a way that every vector inside of this box will now be a vector with individual coordinate values between 0 and 1. Or that for any vector $\vec{v'}$ in the space it is true that $[0,0,0] \leq \vec{v'} \leq [1,1,1]$.

  %#5
  \item
    \begin{enumerate}
      \item \textbf{A} describes a transformation that first rotates 90 degrees ($\pi / 2$) about the x-axis. Then, it also does another rotation about the z-axis for that same amount.
      \item On the other hand, \textbf{B} describes a transformation that rotates first by 90 degrees about the z-axis followed after by a rotation about the x-axis.
      \item While the two matrices are equal, the products are NOT equal since matrix multiplication is not commutative. A simple example is to think of a vector with components $[1,0,1]$. Rotating about the x-axis then the z-axis would yield a new vector $[1,1,0]$. However, rotating this vector about the z-axis then the x-axis yields a different vector: $[1,-1,1]$.
    \end{enumerate}

  %#6
  \item
    \begin{enumerate}
      \item A scene-graph is like a tree, where the root points to its children. It is a hierarchy. We used a BranchGroup as the root node and created many TransformGroup objects as the children in this hierarchy structure for our own Java3D program.
      \item The nodes in the scenegraph hold information about the objects in the diagram. Each group object (be it a BranchGroup, TransformGroup, etc.) has some common features such as accessing its children and also checking the bounds of the object. Accessing children is important for tree traversal, and the bounds are important for calculating collisions and for hidden surface removal/culling. All the information to draw the object on the screen (location in space, bounds, color, etc.) is important to be stored inside the node so that individual objects can have custom locations and colors on the screen. The bounds are important when collision detection of nodes is being done to reduce the amount of drawing on the screen.
    \end{enumerate}

  %#7
  \item The material composition of an object can be defined through several different colors. We used several in class: object color, ambient color, emissive color, and specular color. Object color is the color that the base of the object will be when lit/illuminated (like paint). Another name as the API calls it for this color is the diffuse color. Now, the ambient color is the color of the ligh that gets reflected off of the surface of the material. And the specular color is the color of the highlights or ``shiny'' spots of the object. Lastly, the emissive color is the color of light that the object itself emits (not reflects, emits).

  %#8
  \item Computer scientists like to calculate out \textbf{r} so that we can properly model the light rays in a scene. Ray tracing commonly uses this but in the opposite direction, starting first at a vector from the eye and tracing it the light source, seeing how close the vector from the surface to the light source is compared to the vector that reflects off of what the eye sees of the surface. For this and other shading algorithms, we calculate the reflected ray to compare the vectors (simple dot product to compare vectors) which will let the software know how little or how much to shade the surface. The closer the dot product of the unit vectors of the light source and eye are to 1 then the brighter the object appears.

  %#9
  \item
    \begin{enumerate}
      \item The sum of each of these curves and their four functions is the same. This sum is 1.
      \item B-splines have a greater amount of continuity in the resulting curve. This is because the algorithm for B-splines incorporates the second derivative matching, beyond the Bezier curve first derivative slope-matching. Since second derivatives relate to curvature this is important to make the function appear smoother. It also means less kinks and weird looking curves that Bezier curves sometimes produce.
      \item These nicer looking curves of course come at a cost. Looking at the functions alone, one can see how a higher-order polynomial function is more costly to compute, since this is what the B-spline depends on for the algorithm to work and generate the smooth curve. Also, the B-spline typically loses the first and last point in the computation when attempting to smooth the curve (though certain algorithms can estimate these points back in). Lastly, we also discussed briefly in class that B-splines do not work as well for circular arcs.
    \end{enumerate}

  %#10
  \item
    \begin{enumerate}
      \item If the expression evaluates to zero, then we know that the point $(x,y)$ lies on the line. However, if the point is either positive or negative, then we know that the point lies ``above'' or ``below'' the line. Above the line will yield a positive value while below the line yields a negative value.
      \item Similarly, with some arbitrary point \textbf{p} we can find out if it lies in the plane by evaluating that expression, and it comes out to be zero for all points in the plane. Again, if the value is positive then the point lies above the plane, otherwise the value is negative for all points below the plane.
      \item The former method is rather useful when it comes to hidden surface removal or culling. By examining points in 3-dimensions, the points or objects closer to the camera will be the ones to be rendered. The rest of the objects can be ignored if they are completely covered by another object (akin to layering and deleting layers that are not visible). By comparing points of one object and the plane of another object we can find out which object is closer to the camera. It would be wise to be wary of which sign you want (positive or negative); this will depend on the way the coordinate system is setup and defined.
    \end{enumerate}

  %#11
  \item
    \begin{enumerate}
      \item BSP is used for the type of problem just described in the previously problem: hidden surface removal. It is also useful in collision detection (when planes overlap or touch). BSP is a type of tree-like data structure that sub-divides the scene to make the calculations more efficient when it comes to re-orienting the camera in the scene, since the data stored in the tree remains the same essentially. Thus, there is no need to re-calculate every single collision for a rotating/moving camera.
      \item In class we did mention another more efficient algorithm called the z-buffer algorithm, which simply uses an array to store the z-coordinate of the objects to be displayed on the screen. These two algorithms are not necessarily exclusive, however. And there are advantages and disadvantages to each (z-buffer is faster with many, many triangles, BSP is faster with more complex shapes and reduces the amount of error). I will assume the alternative you are referring to is the obviously inefficient painter's algorithm which simply displays everything on the screen, like painting layers on a canvas. Some layers may get covered, but the algorithm does not ``care,'' it simply does its job and gets everything displayed.
      \item Now obviously, the painter's algorithm is slow since it displays everything on the screen, redrawing for all objects that are covered. The advantage of BSP is to skip over these unseen objects through hidden surface removal. Another useful advantage of BSP is that the data for the tree can be used from all different camera angles, which is not true for the z-buffer algorithm which would have to re-calculate for each triangle in the scene. And as stated, the BSP algorithm may also hold more complex shapes and run faster than the simple z-buffer algorithm would otherwise do, since it compares triangles as opposed to BSP's more advanced hierarchy data structure.
    \end{enumerate}

  %#12
  \item
    \begin{enumerate}
      \item Geometry of each object is essentially the points that are described in each of these data structures. Figuring out any other points (along edges or faces) is left up to the relation of the other points and the topology of the object. The topology is stored in each data structure as well. The winged edge structure relates faces to the edges around it (which in turn relates to the points to get the geometry of the object). Each edge is defined by connecting it to its two faces and the four other edges until each edge is traversed. And, the DCEL structure incorporates topology by splitting up each edge into two half-edges, connecting the half-edge to the face to its left, and relating each edge to its following edge as the half-edges traverse across the entire object.
      \item Creating meshes in POV-Ray is meant to be simple. One can simply define each triangle separately with all its points. This is the process of using triangle strips to form a mesh. Another method is the ``mesh2'' option in POV-Ray which allows one to define all points in the object and use indices to connect those points into triangles separately. This process is the index array method to forming a mesh. Lastly, it appears that Java3D has two classes to also do the same thing: TriangleStripArray and IndexedTriangleStripArray.
    \end{enumerate}

  %#13
  \item See attached document entitled `Applications in Computer Graphics: Java \& Minecraft.'

  %#14
  \item See attached document entitled `Blender \& Physics Simulations.'

  %#15
  \item It is important for a student learning computer graphics to understand how to define and create their own scenegraph inside of a programming language. We did this in class using Java3D. But there are many software packages and solutions out there that use scenegraphs in one form or another. For example, Blender has many options to connect groups of objects together in a scenegraph-like way, since there is that hierarchy of objects. It is something that we did not really mention much in the course, but it was something I found when doing research and did not have enough time to experiment and play around with it. Many modelling programs and 3-D programs will utilize a scenegraph since this ultimately makes the scene easier to enhance and render. It is also important to understand some of the basics behind the data structures used for computer graphics, but it is quite possible that the scenegraph might be the most important one that is utilized in higher-level programs. In a sense, scenegraphs are akin to the notion of object-oriented programming too, so this understanding enhances that aspect of computer science as well.

\end{enumerate}

\end{document}
